#!/usr/bin/env python3

'''
This is the top-level live-game script. This module is primarily responsible
for building and managing the curses UI, and for coordinating with the game
state and api backend modules.
'''

import click
import curses
import curses.ascii
import os
import pathlib
import random
import sys

from typing import Any, List, Optional

from live_game.game.game import Game, Character

# Global names initialization

# "Camel_Cased" names indicate global variables; variables may be changed by
#   text input from the user
# "ALL_CAPS" names indicate global constants

Game_State = None       # the game state backend object

STDSCR = None           # the curses screen object

Height = 0              # the height of the terminal/curses window
Width = 0               # the width of the terminal/curses window

INIT_BOX = None         # the initiative box object
INIT_BOX_TITLE = "Initiative Tracker"
Init_Box_Width = 0
Init_List_Lower_Index = 0   # tracker for scrolling text
Init_List_Upper_Index = 0   # tracker for scrolling text
Init_Box_Text = ''
Init_Cursor_Max_Upper = 0

STATUS_BOX = None   # the status box object
STATUS_BOX_TITLE = "Status"
Status_Box_Width = 0
# status box height is tracked from the curses UI
Status_Cursor_Max_Upper = 0   # The Status box is not manually scrolled by
                              # users; the text list for the status box is
                              # instead rearranged by ui logic in response to
                              # user interactions with the INIT box; therefore
                              # we need not track a lower index for displayed
                              # text, as it will always be 0
# status box text is generated by the Game backend

MENU_BOX = None     # the menu box object
MENU_BOX_TITLE = "Menu"
Menu_Box_Width = 0
Menu_Box_Height = 0
# menu box text items are static and not scrolled, therefore we need not track
# text indices
Menu_Box_Text = ''

LOG_BOX = None      # the log box object
LOG_BOX_TITLE = "Log"
Log_Box_Width = 0
# The legend box height is tracked from the curses UI
# The legend box is not scrollable and the text list is constrained to the
# size of the text window, so we need not track text indices

LEGEND_BOX = None   # the legend box object
LEGEND_BOX_TITLE = "Legend"
Legend_Box_Width = 0
Legend_Box_Height = 0
Legend_Box_Text = ''
Legend_Text_Low = 0     # the legend box is manually scrollable via l or L
Legend_Text_High = 0    # therefore we need to track the text window

HELP_PANEL = None   # the object for contextual help text
HELP_PANEL_HEIGHT = 1

INPUT_PANEL = None  # the object for the text input box
INPUT_PANEL_HEIGHT = 3   # the static height of the input panel
Max_Buffer_Len = 0      # the max (horizontal) length of the input buffer

BOX_HEADER_PADDING = 4   # the number of spaces from the visual top of a box to leave before we render the box content text
BOX_HEIGHT_PADDING = 5  # BOX_HEADER_PADDING plus one for the border line at the visual bottom of a box
BOX_BORDER_PADDING = 2  # constant to account for box borders in computations
CURSOR_START_PADDING = 2    # constant to indicate how many spaces from the left edge of a box to put the cursor or start text display

BASE_DIR = os.path.expanduser('dm-tools/live_game/')    # top level dir of where to find files relevant to this module
PCS_FILENAME = 'pcs.yaml'   # the default filename for saving/loading combatants
WRITE_CHANGES = True    # whether or not to overwrite the game state file
YAML_DIR = 'yamls/'     # where to read/write game state yaml files

CUR_BOX = None              # tracker for which box is currently selected (note: alternate box selection is currently deprecated)
CUR_BOX_OPTIONS = None      # which keystroke options are available for the currently selected box
CUR_BOX_TEXT = None         # tracker for the display text for the current box
CUR_BOX_TITLE = None        # title of the currently-selected box
Cursor_Index = 0            # where the cursor is in the currently-selected box

# Dispatch Tables for UI Controls

# initiative-related controls
INIT_OPTION_TUPLES = {
    'a': (lambda: add_character(), 'Add Character'),
    'x': (lambda: clear_init(), 'Clear Initiative'),
    't': (lambda: defer_initiative(), 'Defer Turn'),
    'n': (lambda: handle_next(), 'Next Character'),
    'r': (lambda: remove_character(), 'Remove Character'),
    's': (lambda: sort_init_list(), 'Sort List'),
    '1-99': (lambda: set_initiative(), 'Set Initiative'),
    'l': (lambda: scroll_legend_down(), 'Scroll Legend'),
    'b': (lambda: set_init_bonus(), 'Set Initiative Bonus'),
    'i': (lambda: auto_initiative(), 'Auto Initiative'),
}

# status-related controls
STATUS_OPTION_TUPLES = {
    'a': (lambda: add_character(), 'Add Character'),
    'c': (lambda: add_condition(), 'Condition Add'),
    'd': (lambda: delete_condition(), 'Delete Condition'),
    'h': (lambda: set_hp(), 'Set HP'),
    '-/+': (lambda: set_hp(), 'Edit temp HP'),
}

# all controls put together
ALL_OPTIONS_TUPLES = {**INIT_OPTION_TUPLES, **STATUS_OPTION_TUPLES}

# contextual help text
HELP_TEXT = {
    'Add': 'Enter name of combatant',
    'Cancel': 'Hit `\u0331 (backtick) to Cancel',
    'Conditions': 'Enter a condition',
    'Hp': 'Enter a number to set max HP; prepend -/+ to adjust temp HP',
    'InitBonus': 'Enter a number to set initiative bonus',
    'Quit': 'Hit q\u0331 to Quit',
    'Remove': 'Select condition icon to remove',
    INIT_BOX_TITLE: '  '.join([k+'\u0331: {}'.format(v[1]) for k,v in
                               INIT_OPTION_TUPLES.items()]),
    STATUS_BOX_TITLE: '  '.join([k+'\u0331: {}'.format(v[1]) for k,v in
                                 STATUS_OPTION_TUPLES.items()]),
}

# Curses Strings For Various Keystrokes

UP_DOWN_KEYS = [
    'KEY_UP',
    'KEY_DOWN',
]

RIGHT_LEFT_KEYS = [
    'KEY_RIGHT',
    'KEY_LEFT',
]

ENTER_KEY = '\n'
ESC_KEY = '`'
FINAL_KEYS = [ENTER_KEY, ESC_KEY]


def add_character() -> str:
    '''
    Get user input to add a combatant to the game state and adjust text
    display as necessary. The game state
    will check with the API backend (make a GET call) to see if the character
    exists in the SRD

    :returns: a log message string
    '''
    display_help_text('; '.join([HELP_TEXT['Add'], HELP_TEXT['Cancel']]))
    name = get_input(helptext=HELP_TEXT['Add'])
    if len(name) < 1:
        return "no input"

    Game_State.add_character(name)
    if len(Game_State.initiative_list) <= Init_Cursor_Max_Upper:
        adjust_init_text_window(Init_List_Lower_Index, Init_List_Upper_Index+1)
    else:
        adjust_init_text_window(Init_List_Lower_Index+1, Init_List_Upper_Index+1)

    return f'Add {name}'


def add_condition() -> str:
    '''
    Get user input to add a condition to a combatant in the game state.
    Conditions must currently be spelled out completely

    :returns: a log message string
    '''
    display_help_text('; '.join([HELP_TEXT['Conditions'], HELP_TEXT['Cancel']]))
    name = Init_Box_Text[Cursor_Index]
    name = ' '.join(name.split()[1:])
    cond = get_input(helptext=HELP_TEXT['Conditions'])
    if len(cond) < 1:
        cond += "no input"
        status = 'failure'
    elif cond not in Game_State.condition_emoji.keys():
        cond += " unknown"
        status = 'failure'
    else:
        status = Game_State.set_condition(name, cond)
    return f'added condition {cond} to {name} {status}'


def adjust_init_text_window(lower_val, upper_val) -> None:
    '''
    Adjust init box text window in order to scroll text

    Returns None
    '''
    global Init_List_Lower_Index
    global Init_List_Upper_Index
    global Init_Box_Text
    Init_List_Lower_Index = lower_val
    Init_List_Upper_Index = upper_val
    Init_Box_Text = Game_State.initiative_list[Init_List_Lower_Index:Init_List_Upper_Index+1] if len(Game_State.initiative_list) > 0 else []
    INIT_BOX.clear()


def auto_initiative() -> str:
    '''
    Roll initiative values for combatants taking their bonuses into account and
    sort the combatants in descending order by initiative

    :returns: a log message string
    '''

    rolls = []

    for pc in Game_State.pcs:
        roll = random.randint(1, 20)
        rolls.append(f'  {pc}: {roll}')
        bonus = Game_State.pcs[pc].init_bonus
        result = roll + bonus
        Game_State.set_initiative(pc, str(result))


    sort_init_list()
    return ['Auto Initiative'] + rolls


def clear_help_text() -> None:
    '''
    Remove help text from the help text panel

    Returns None
    '''
    HELP_PANEL.clear()
    HELP_PANEL.addstr(0, CURSOR_START_PADDING, '')
    HELP_PANEL.refresh()


def clear_init() -> str:
    '''
    Set all initiative values to zero

    :returns: a log message string
    '''
    Game_State.clear_init()
    INIT_BOX.clear()
    return 'Clear Initiative'


def clear_refresh_all() -> None:
    '''
    clear and refresh all boxes

    Returns None
    '''
    STDSCR.clear()
    STDSCR.refresh()
    INPUT_PANEL.clear()
    INPUT_PANEL.refresh()
    HELP_PANEL.clear()
    HELP_PANEL.refresh()
    INIT_BOX.clear()
    INIT_BOX.refresh()
    STATUS_BOX.clear()
    STATUS_BOX.refresh()
    LOG_BOX.clear()
    LOG_BOX.refresh()


def defer_initiative() -> str:
    '''
    Move the current combatant to "the end of the turn" in initiative order.
    This preserves the combatant's initiative score, and just moves them
    to just before the player with the highest initiative score

    :returns: a log message string
    '''
    if len(Init_Box_Text) < 1:
        return 'no combatants present'
    init_and_name_list = Init_Box_Text[0].split()
    name = ' '.join(init_and_name_list[1:])
    Game_State.defer_initiative()
    INIT_BOX.clear()
    return f'defer: {name}'


def delete_condition() -> str:
    '''
    Allow user to use the cursor to select a condition on the currently-
    selected combatant for removal

    :returns: a log message string
    '''
    display_help_text('; '.join([HELP_TEXT['Remove'], HELP_TEXT['Cancel']]))
    name = Init_Box_Text[Cursor_Index]
    name = ' '.join(name.split()[1:])
    conds = Game_State.pcs[name].conditions

    if len(conds) < 1:
        return f'No conditions to remove for {name}'

    # move cursor to condiitons array
    conds_string = conds.strip()[3:]
    bang_len = 6
    
    cond_to_remove = nav_conditions(name, conds)
    if cond_to_remove == '':
        return f'Remove condition from {conds} for {name} canceled'
    cond_name = Game_State.remove_condition(name, cond_to_remove)
    STATUS_BOX.clear()
    return f'remove condition {cond_name} from {name}'


def display_help_text(text) -> None:
    '''
    Show a help message on the help panel

    Returns None
    '''
    HELP_PANEL.clear()
    if len(text) > Max_Buffer_Len:
        text = text[:Max_Buffer_Len]

    HELP_PANEL.addstr(0, CURSOR_START_PADDING, text, curses.A_STANDOUT)
    HELP_PANEL.refresh()


def execute_box_choice(text: str) -> str:
    '''
    Dispatch a function based on the text argument

    :returns: a log message string
    '''
    if text is None or len(text) < 1:
        return 'no input to execute'
    elif text.isdigit():
        text = text.split()[0]
        if len(Init_Box_Text) < 1:
            return 'no combatants present'
        name = Init_Box_Text[Cursor_Index]
        name = ' '.join(name.split()[1:])
        Game_State.set_initiative(name, text)
        INIT_BOX.clear()
        return f'Set initiative: {name} {text}'
    elif text[0] in ['-', '+']:
        return set_hp(text)
    elif text == 'l':
        return scroll_legend_down()
    elif text == 'L':
        return scroll_legend_up()
    elif text.lower() in ALL_OPTIONS_TUPLES.keys():
        if len(Init_Box_Text) < 1 and text.lower() != 'a':
            return 'no combatants present'
        return ALL_OPTIONS_TUPLES[text.lower()][0]()


def get_input(keys: Optional[str] =None, helptext: str ='') -> str:
    '''
    Render the cursor and any inputted text in the input panel, allowing
    for backspacing

    :param keys: a string of text already input so far
    :param helptext: contextual help text to display in the Help Panel
    :return: user-input text
    '''

    INPUT_PANEL.move(1, 1)
    INPUT_PANEL.clear()
    ret = '' if keys is None or keys in FINAL_KEYS else keys
    INPUT_PANEL.addstr(1, 1, ret)
    render_input_panel()
    key = INPUT_PANEL.getkey()
    while key not in FINAL_KEYS and len(ret) < Max_Buffer_Len:
        if key == 'KEY_BACKSPACE':
            ret = ret[:-1]
        else:
            if len(key) == 1:
                ret += key
        INPUT_PANEL.addstr(1, 1, ret)
        key = INPUT_PANEL.getkey()
        INPUT_PANEL.clear()
        render_input_panel()
    clear_help_text()
    if key == ESC_KEY:
        INPUT_PANEL.clear()
        return ''
    INPUT_PANEL.clear()
    return ret


def handle_next() -> str:
    '''
    Take a step in the initiative list

    Redisplays the initiative list with the next player at the top

    :returns: a log message string
    '''
    Game_State.next_initiative()
    INIT_BOX.clear()
    return ' '.join(Init_Box_Text[0].split()[1:])


def is_float(s: str) -> bool:
    '''
    Returns true if the string passed can be cast to a float value, false
    otherwise
    '''
    try:
        if not any([c == '.' for c in s]):
            return False
        float(s)
        return True
    except ValueError:
        return False


def is_integer(s: str) -> bool:
    '''
    Returns true if the string passed can be cast to an integer value, false
    otherwise
    '''
    try:
        int(s)
        return True
    except ValueError:
        return False


def legend_box_text() -> List[str]:
    '''
    Compile and return text list for the legend box

    :return: a list of strings
    '''
    status_icons = [i + ': ' + s.capitalize() for (i, s) in \
                    zip(Game.attribute_icons, Character.legend_attributes)]
    conditions = ['Conditions', '---'] + \
     [i + ': ' + s.capitalize() for (i, s) in \
      zip(Game.condition_emoji.values(), Game.condition_emoji.keys())]

    modified_kv = [(k,v) for (k,v) in Game.damage_types.items() if k != "bludgeoning, piercing, and slashing from nonmagical weapons that aren't silvered"]
    modified_kv[-2] = ('Nonsilvered nonmagical', modified_kv[-2][1])
    modified_kv[-1] = ('Nonmagical', modified_kv[-1][1])
     
    damage = ['Dmg Types', '---'] + \
     [i + ': ' + s.capitalize() for (s, i) in modified_kv]

    return status_icons + [' '] + conditions + [' '] + damage


def max_len_append(new_item: Any, the_list: List[Any], max_len: int) -> List[str]:
    '''
    Append a string to a list, or else concatenate two lists. A non-string
    new_item will be cast as a string before appending it.

    This function drops the first items in the list in order to constrain its
    return list to a size no longer than max_len

    :param new_item: an item to cast to a string and add to the_list, or else
                     a list to concatenate with the_list
    :param the_list: a list of things to which to add new_item
    :param max_len: an integer N: this function returns the last N items in the
                    total constructed list
    :returns: a list of length <= max_len
    '''
    if new_item is None:
        return the_list
    if type(new_item) == str:
        the_list.append(new_item)
    elif type(new_item) == list:
        the_list.extend(new_item)
    else:
        the_list.append(str(new_item))

    ln = len(the_list)
    diff = ln - max_len
    if diff >= 0:
        the_list = the_list[diff:]

    LOG_BOX.clear()

    return the_list


def nav_conditions(name: str, conds: str) -> str:
    '''
    Presents an interactive navigation for the user to allow them to use the
    cursor to select a condition for removal.

    This function has to do some futzy logic to correlate fun differences in
    Unicode display width (glyph width) with the length of the character as
    stored in a string. I've half-solved this problem by trying to use only
    emojis with a glyph width of 2, and by placing spaces between emojis in
    the condition string for better-looking rendering, which is why this
    function is checking to see if the character under its cursor is 
    whitespace or not.

    :param name: the name of the combtant whose condition is to be removed
    :param conds: the current conditions for that combatant
    :returns: a single-character string that contains the emoji corresponding
              to the condition to be removed
    '''
    global STATUS_BOX
    buf = 0
    index = 0
    horiz_buffer = 6 # two spaces of indent plus length of '!: '
    conditions_index_for_top_entry = 2
    STATUS_BOX.move(BOX_HEADER_PADDING + conditions_index_for_top_entry,
                    CURSOR_START_PADDING + horiz_buffer)
    key = STATUS_BOX.getkey()
    string = conds
    len_string = len(string)
    while key not in FINAL_KEYS:
        if key in RIGHT_LEFT_KEYS:
            if key == 'KEY_RIGHT' and index < len_string-1:
                if string[index] != ' ':
                    buf += 2
                else:
                    buf += 1
                index += 1
            elif key == 'KEY_LEFT' and index > 0:
                if string[index] != ' ':
                    buf -= 1
                else:
                    buf -= 2
                index -= 1
        STATUS_BOX.move(BOX_HEADER_PADDING + conditions_index_for_top_entry,
                             CURSOR_START_PADDING+horiz_buffer+buf)
        key = STATUS_BOX.getkey()
    if key == ENTER_KEY:
        if string[index] == ' ':
            return string[index-1]
        return string[index]
    else:
        return ''


def navkey_to_index(keystroke: str, text_list: List[str], cursor_index: int, box: Any) -> int:
    '''
    This function converts a curses keystroke string, a list of text (should be
    the Init_Box_Text; this is not hardcoded for now for legacy reasons),
    and a current cursor index into a new index for where the cursor should
    be given the current status of the window.

    This function may trigger stateful updates in displayed text.

    :param keystroke: a string representing a curses keystroke
    :param text_list: the full list of text for which a display window must
                      potentially be managed
    :param cursor_index: an integer indicating where in the box the cursor
                         currently sits
    :returns: an integer representing the new cursor position in the displayed
              window
    '''
    len_list = len(text_list)
    if len_list < 1:
        return 0
    top_list_index = len_list - 1
    relevant_lower = Init_List_Lower_Index
    relevant_upper = Init_List_Upper_Index
    relevant_max = Init_Cursor_Max_Upper

    if keystroke == 'KEY_UP' and cursor_index <= 0:
        if relevant_lower <= 0:
            if len_list < relevant_max:
                return top_list_index
            else:
                adjust_init_text_window(top_list_index-relevant_max, len_list)
                return relevant_max
        else:
            adjust_init_text_window(relevant_lower-1, relevant_upper-1)
            return 0
    elif keystroke == 'KEY_DOWN' and (cursor_index >= top_list_index or \
         (len_list == relevant_max+1 and cursor_index >= relevant_upper-1) or \
         (len_list > relevant_max+1 and cursor_index >= relevant_max and relevant_upper == len_list)):
        adjust_init_text_window(0, relevant_max+1)
        return 0
    elif keystroke == 'KEY_DOWN' and cursor_index >= relevant_max and \
            relevant_upper < len_list:
        adjust_init_text_window(relevant_lower+1, relevant_upper+1)
        return cursor_index
    elif keystroke == 'KEY_UP':
        return cursor_index - 1
    elif keystroke == 'KEY_DOWN':
        return cursor_index + 1
    else:
        return cursor_index


def remove_character(name: Optional[str] =None) -> str:
    '''
    Remove a combatant from the game state and update the text for display

    :param name: optionally the name of the combatant for removal
    :returns: a log message string
    '''
    global Init_Box_Text
    if len(Init_Box_Text) < 1:
        return f'no combatants to remove'

    global Cursor_Index
    if name is None or name not in Game_State.pc_names:
        init_and_name_list = Init_Box_Text[Cursor_Index].split()
        name = ' '.join(init_and_name_list[1:])

    Game_State.remove_character(name)
    if len(Game_State.initiative_list) > 0:
        adjust_init_text_window(Init_List_Lower_Index, Init_List_Upper_Index-1)
    else:
        adjust_init_text_window(0, 0)
    if len(Init_Box_Text) < 1:
        Cursor_Index = 0
    elif Cursor_Index >= len(Init_Box_Text):
        Cursor_Index = len(Init_Box_Text)-1
    INIT_BOX.clear()
    STATUS_BOX.clear()
    return f'remove: {name}'


def render_box(box: Any, height: int, width: int, title: str, strings: List[str]) -> None:
    '''
    Render a bordered box in the curses UI according to the arguments.

    :param box: the box object to render
    :param height: an int representing the total height of the box
    :param width: an int representing the total width of the box
    :param title: a string to act as the title of the box in its header
    :param strings: a list of strings to act as text content for the box
    :returns: None
    '''
    box.box()
    box.addstr(1, CURSOR_START_PADDING, title)
    box.addstr(CURSOR_START_PADDING, 1, ''.join('-' for i in range(width-CURSOR_START_PADDING)))
    start = BOX_HEADER_PADDING
    for string in strings:
        if start == height-INPUT_PANEL_HEIGHT:
            break
        try:
            if len(string) >= width-BOX_HEADER_PADDING:
                box.addstr(start,
                           CURSOR_START_PADDING, string[:width-BOX_HEADER_PADDING])
            else:
                box.addstr(start, CURSOR_START_PADDING, string)
        except Exception:
            continue
        start += 1


def render_box_highlight_text(box: Any, height: int, width: int, title: str, strings: List[str], index: int) -> None:
    '''
    Render a curses box according to the arguments, but with one line of text
    content hilighted

    :param box: the curses box object
    :param height: an int representing the total height of the box
    :param width: an int representing the total width of the box
    :param title: a string to act as the box title in the header
    :param strings: a list of strings to act as text content for the box
    :param index: an int representing which line in strings to highlight
    :returns: None
    '''
    box.box()
    box.addstr(1, CURSOR_START_PADDING, title)
    box.addstr(CURSOR_START_PADDING, 1, ''.join('-' for i in range(width-CURSOR_START_PADDING)))
    start = BOX_HEADER_PADDING
    for i, string in enumerate(strings):
        if len(string) >= width-BOX_HEADER_PADDING:
            string = string[:width-BOX_HEADER_PADDING]
        if i == index:
            box.addstr(start, CURSOR_START_PADDING, string, curses.A_STANDOUT)
        else:
            box.addstr(start, CURSOR_START_PADDING, string)
        start += 1


def render_input_panel() -> None:
    '''
    Render the input panel at the bottom of the UI
    :returns: None
    '''
    INPUT_PANEL.box()


def scroll_legend_down() -> None:
    '''
    Adjust the legend box text to scroll downward in the text content
    :returns None:
    '''
    global Legend_Text_Low
    global Legend_Text_High

    Legend_Text_Low += 1
    Legend_Text_High += 1

    if Legend_Text_High > len(Legend_Box_Text):
        Legend_Text_Low = 0
        Legend_Text_High = Legend_Box_Height - BOX_BORDER_PADDING - BOX_HEIGHT_PADDING
    elif Legend_Text_Low < 0:
        Legend_Text_High = len(Legend_Box_Text)
        Legend_Text_Low = Legend_Text_High - (Legend_Box_Height - \
            (BOX_BORDER_PADDING + BOX_HEIGHT_PADDING))

    LEGEND_BOX.clear()


def scroll_legend_up() -> None:
    '''
    Adjust the legend box text to scroll upward in the text content
    :returns None:
    '''
    global Legend_Text_Low
    global Legend_Text_High

    Legend_Text_Low -= 1
    Legend_Text_High -= 1

    if Legend_Text_High > len(Legend_Box_Text):
        Legend_Text_Low = 0
        Legend_Text_High = Legend_Box_Height - BOX_BORDER_PADDING - BOX_HEIGHT_PADDING
    elif Legend_Text_Low < 0:
        Legend_Text_High = len(Legend_Box_Text)
        Legend_Text_Low = Legend_Text_High - (Legend_Box_Height - \
            (BOX_BORDER_PADDING + BOX_HEIGHT_PADDING))

    LEGEND_BOX.clear()


def set_hp(text: Optional[str] =None) -> str:
    '''
    Get input from user to set either the max or temp HP for a combatant

    :param text: a string representing either a float or an int; a float
                 indicates that setting max hp is desired; a positive or
                 negative int indicates that a change to temp hp is desired;
                 If this string is None, this function will get input from
                 the user
    :returns: a log message string
    '''
    display_help_text('; '.join([HELP_TEXT['Hp'], HELP_TEXT['Cancel']]))
    if len(Init_Box_Text) < 1:
        return 'no combatants present'
    name = Init_Box_Text[Cursor_Index]
    name = ' '.join(name.split()[1:])

    if text is None or len(text) < 1:
        change = get_input()
    else:
        change = text
    if not is_integer(change) and not is_float(change):
        return 'non-integer input'

    change_type = None
    change_str = change
    if change[0] == '-' or change[0] == '+':
        change_type = change[0]
        change = change[1:]
    else:
        change_type = 'set max'

    Game_State.update_hp(name, change, change_type, WRITE_CHANGES)

    STATUS_BOX.clear()
    return ' '.join([name, change_str])


def set_init_bonus(text: Optional[str] =None) ->  str:
    '''
    Set the initiative bonus to the passed in value for the combatant
    currently under the cursor

    :param text: an optional string representing the integral value at which
                 to set the combatant's initiative bonus; otherwise this
                 function will get input from user
    :returns: a log message string
    '''
    display_help_text('; '.join([HELP_TEXT['InitBonus'], HELP_TEXT['Cancel']]))
    if len(Init_Box_Text) < 1:
        return 'no combatants present'
    name = Init_Box_Text[Cursor_Index]
    name = ' '.join(name.split()[1:])

    if text is None or len(text) < 1:
        change = get_input()
    else:
        change = text

    if not is_integer(change):
        return 'non-integer input'

    Game_State.set_init_bonus(name, int(change))

    STATUS_BOX.clear()
    return ' '.join([name, change])


def sort_init_list() -> str:
    '''
    Sort the list of combatants in descending order by initiative score

    :returns: a log message string
    '''
    Game_State.sort_init_list()
    INIT_BOX.clear()
    return 'sort init descending'


def main(pcs, write_changes):

    # Bring globals into the function scope

    global STDSCR
    global INIT_BOX
    global Init_Box_Width
    global Init_Cursor_Max_Upper
    global Init_List_Lower_Index
    global Init_List_Upper_Index
    global Init_Box_Text
    global STATUS_BOX
    global Status_Box_Width
    global Status_Cursor_Max_Upper
    global MENU_BOX
    global Menu_Box_Width
    global Menu_Box_Height
    global Menu_Box_Text
    global LOG_BOX
    global Log_Box_Width
    global LEGEND_BOX
    global LEGEND_BOX_TITLE
    global Legend_Box_Width
    global Legend_Box_Height
    global Legend_Box_Text
    global Legend_Text_Low
    global Legend_Text_High
    global Game_State
    global Height
    global HELP_PANEL
    global INPUT_PANEL
    global Max_Buffer_Len
    global Width
    global WRITE_CHANGES
    global CUR_BOX
    global CUR_BOX_OPTIONS
    global CUR_BOX_TEXT
    global CUR_BOX_TITLE
    global Cursor_Index

    # Initialize Game State

    kwargs = {}
    kwargs['pcs_yaml'] = pcs

    Game_State = Game(**kwargs)

    if not write_changes:
        WRITE_CHANGES = False

    # Initialize UI
    
    Height, Width = STDSCR.getmaxyx()
    Height -= BOX_BORDER_PADDING
    Width -= BOX_BORDER_PADDING
    Max_Buffer_Len = Width
    Menu_Box_Text = sorted([' '.join([k, v[1]]) for k, v in
                     ALL_OPTIONS_TUPLES.items()])
    Menu_Box_Width = max([len(s) for s in Menu_Box_Text]) + BOX_HEADER_PADDING
    Init_Box_Width = 40
    Status_Box_Width = 40
    Legend_Box_Text = legend_box_text()
    Log_Box_Width = Width - Menu_Box_Width - Init_Box_Width - \
                    Status_Box_Width - 3

    HELP_PANEL = curses.newwin(1, Width, Height-2, 0)

    Menu_Box_Height = len(Menu_Box_Text) + BOX_BORDER_PADDING + BOX_HEIGHT_PADDING
    MENU_BOX = curses.newwin(Menu_Box_Height-BOX_BORDER_PADDING, Menu_Box_Width, 0,
                             0)
    MENU_BOX.immedok(True)
    MENU_BOX.keypad(True)

    INPUT_PANEL = curses.newwin(3, Width, Height-1, 0)
    INPUT_PANEL.immedok(True)
    INPUT_PANEL.keypad(True)

    INIT_BOX = curses.newwin(Height-BOX_BORDER_PADDING, Init_Box_Width, 0,
                             Menu_Box_Width + 1)
    INIT_BOX.immedok(True)
    INIT_BOX.keypad(True)
    Init_Cursor_Max_Upper = Height - BOX_HEADER_PADDING - INPUT_PANEL_HEIGHT - HELP_PANEL_HEIGHT
    Init_List_Lower_Index = 0
    Init_List_Upper_Index = min(Init_Cursor_Max_Upper,
                                max(len(Game_State.initiative_list)-1,
                                    Init_List_Lower_Index))
    Init_Box_Text = Game_State.initiative_list[Init_List_Lower_Index:Init_List_Upper_Index+1] if len(Game_State.initiative_list) > 0 else []

    Legend_Box_Width = Menu_Box_Width
    Legend_Box_Height = Height - Menu_Box_Height + BOX_BORDER_PADDING
    Legend_Text_High = Legend_Box_Height - BOX_BORDER_PADDING - BOX_HEIGHT_PADDING
    if Legend_Text_High > len(Legend_Box_Text):
        Legend_Text_High = len(Legend_Box_Text)
    LEGEND_BOX = curses.newwin(Legend_Box_Height-BOX_BORDER_PADDING,
                               Legend_Box_Width, Height - Legend_Box_Height,
                               0)

    LEGEND_BOX.immedok(True)
    LEGEND_BOX.keypad(True)

    STATUS_BOX = curses.newwin(Height-BOX_BORDER_PADDING, Status_Box_Width, 0,
                               Menu_Box_Width + Init_Box_Width + 2)
    STATUS_BOX.immedok(True)
    STATUS_BOX.keypad(True)
    STATUS_BOX.scrollok(True)
    STATUS_BOX.idlok(True)
    Status_Cursor_Max_Upper = Height - (BOX_HEIGHT_PADDING + INPUT_PANEL_HEIGHT)

    CUR_BOX = INIT_BOX
    CUR_BOX_OPTIONS = INIT_OPTION_TUPLES
    CUR_BOX_TEXT = Init_Box_Text
    CUR_BOX_TITLE = INIT_BOX_TITLE

    keystrokes_list = []
    key_list_max_len = Height-8
    LOG_BOX = curses.newwin(Height-BOX_BORDER_PADDING, Log_Box_Width, 0,
                            Init_Box_Width +
                            Status_Box_Width +
                            Menu_Box_Width + 
                            3)
    LOG_BOX.immedok(True)
    LOG_BOX.keypad(True)

    while True:
        STDSCR.refresh()
        h, y = STDSCR.getmaxyx()

        # Handle possible terminal resizes

        if curses.is_term_resized(h, y):
            Height, Width = h, y
            Height -= BOX_BORDER_PADDING
            Width -= BOX_BORDER_PADDING
            Max_Buffer_Len = Width

            Init_Box_Width = 40 if Width > 120 else (Width // 3) - BOX_BORDER_PADDING
            Status_Box_Width = 40 if Width > 120 else (Width // 3) - \
                BOX_BORDER_PADDING
            Log_Box_Width = Width - Menu_Box_Width - Init_Box_Width - \
                            Status_Box_Width - 15
            Legend_Box_Height = Height - Menu_Box_Height + BOX_BORDER_PADDING

            HELP_PANEL.resize(1, Width)
            INPUT_PANEL.resize(3, Width)
            INIT_BOX.resize(Height-BOX_BORDER_PADDING, Init_Box_Width)
            Init_Cursor_Max_Upper = Height - BOX_HEADER_PADDING - INPUT_PANEL_HEIGHT - HELP_PANEL_HEIGHT
            Init_List_Lower_Index = 0
            Init_List_Upper_Index = min(Init_Cursor_Max_Upper,
                                        max(len(Game_State.initiative_list)-1,
                                            Init_List_Lower_Index))
            Init_Box_Text = Game_State.initiative_list[Init_List_Lower_Index:Init_List_Upper_Index+1] if len(Game_State.initiative_list) > 0 else []

            STATUS_BOX.resize(Height-BOX_BORDER_PADDING, Status_Box_Width)
            LOG_BOX.resize(Height-BOX_BORDER_PADDING, Log_Box_Width)
            LEGEND_BOX.resize(Legend_Box_Height, Legend_Box_Width)
            HELP_PANEL.resize(1, Width)
            INPUT_PANEL.resize(3, Width)

            MENU_BOX.mvwin(0, 0)
            INIT_BOX.mvwin(0, Menu_Box_Width + 2)
            STATUS_BOX.mvwin(0, Init_Box_Width + Menu_Box_Width + 4)
            LOG_BOX.mvwin(0, Init_Box_Width +
                          Status_Box_Width +
                          Menu_Box_Width + 
                          5)

            Status_Cursor_Max_Upper = Height - (BOX_HEIGHT_PADDING + INPUT_PANEL_HEIGHT)
            Legend_Text_Low = 0
            Legend_Text_High = Legend_Box_Height - BOX_BORDER_PADDING - BOX_HEIGHT_PADDING
            LEGEND_BOX.mvwin(Menu_Box_Height - BOX_BORDER_PADDING, 0)
            HELP_PANEL.mvwin(Height-2, 0)
            INPUT_PANEL.mvwin(Height-1, 0)
            clear_refresh_all()

        # Render the UI with all computed contents

        if len(Init_Box_Text) > 0:
            name = Init_Box_Text[Cursor_Index]
            name = ' '.join(name.split()[1:])
            Game_State.promote_pc_in_status_list(name)
            adjust_init_text_window(Init_List_Lower_Index, Init_List_Upper_Index)
            STATUS_BOX.clear()

        render_box(MENU_BOX, Menu_Box_Height, Menu_Box_Width, MENU_BOX_TITLE,
                   Menu_Box_Text)
        render_box(INIT_BOX, Height, Init_Box_Width, INIT_BOX_TITLE,
                   Init_Box_Text)
        render_box(STATUS_BOX, Height, Status_Box_Width, STATUS_BOX_TITLE,
                   Game_State.pcs_status_list[:Status_Cursor_Max_Upper+1])
        render_box(LOG_BOX, Height, Log_Box_Width, LOG_BOX_TITLE,
                   keystrokes_list)
        render_box(LEGEND_BOX, Legend_Box_Height, Legend_Box_Width,
                   LEGEND_BOX_TITLE,
                   Legend_Box_Text[Legend_Text_Low:Legend_Text_High])
        render_input_panel()
        display_help_text(HELP_TEXT['Quit'])

        CUR_BOX.move(BOX_HEADER_PADDING + Cursor_Index, CURSOR_START_PADDING)

        # Get and handle user input

        key = CUR_BOX.getkey()

        if key in UP_DOWN_KEYS:
            Cursor_Index = navkey_to_index(key, Game_State.initiative_list,
                                           Cursor_Index, INIT_BOX)
        elif key.lower() == 'q':
            sys.exit(0)
        elif key in RIGHT_LEFT_KEYS:
            continue
        elif key.lower() in ALL_OPTIONS_TUPLES.keys():
            printout = execute_box_choice(key)
            keystrokes_list = max_len_append(printout, keystrokes_list,
                                             key_list_max_len)
        else:
            text = get_input(key)

            printout = execute_box_choice(text)
            keystrokes_list = max_len_append(printout, keystrokes_list,
                                             key_list_max_len)


@click.command()
@click.option('--pcs', '-p', type=click.Path(dir_okay=False,
              writable=True, readable=True), default=f'{BASE_DIR}{YAML_DIR}{PCS_FILENAME}',
              help='name of alternate PCs file')
@click.option('--session-dir', '-d', type=click.Path(dir_okay=True,
              file_okay=False, writable=True, readable=True),
              default=f'{BASE_DIR}{YAML_DIR}',
              help='path to alternate directory for writing session files')
@click.option('--write-changes/--no-write-changes',
              help="Write HP and status changes to original yaml",
              default=True)
def start(pcs, session_dir, write_changes):
    global STDSCR
    global YAML_DIR

    if not os.path.exists(BASE_DIR):
        pathlib.Path(BASE_DIR).mkdir(parents=True, exist_ok=True)
    if not os.path.exists(session_dir):
        pathlib.Path(session_dir).mkdir(parents=True, exist_ok=True)
        YAML_DIR = session_dir
        with open(f'{session_dir}{PCS_FILENAME}', 'w+') as fh:
            fh.write('')
    if not os.path.exists(pcs):
        print("The file provided to --pcs must exist")
        sys.exit(1)

    try:
        STDSCR = curses.initscr()
        curses.start_color()
        curses.use_default_colors()
        curses.init_color(curses.COLOR_RED, 255, 0, 0)
        STDSCR.immedok(True)

        # The following options need to be reversed if they are enabled
        STDSCR.keypad(True)     # curses handles cursor & nav keys
        curses.noecho()   # turns off echoing of keys to screen
        curses.cbreak()   # react to keys instantly, don't wait for Enter

        main(pcs, write_changes)
    finally:
        # Terminate application
        curses.nocbreak()
        curses.echo()
        STDSCR.keypad(False)
        curses.endwin()


if __name__ == '__main__':
    start()
